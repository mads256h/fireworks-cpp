//
// Created by mads on 17-01-25.
//

#include <cassert>
#include <iostream>
#include <fstream>
#include <string>
#include <sstream>
#include <cstdlib>
#include <algorithm>


void embed_resource(std::ofstream& resources_cpp_file,
                    std::stringstream& resources_hpp_file_contents,
                    std::string path) {
    std::string filename = path.substr(path.find_last_of("/\\") + 1);
    std::ranges::replace(filename, ' ', '_');
    std::ranges::replace(filename, '.', '_');

    resources_hpp_file_contents << "extern const std::string_view " << filename << ";\n";

    resources_cpp_file << "const std::string_view resources::" << filename << " = \"";

    std::ifstream file(path, std::ios::binary);

    if (!file.is_open()) {
        std::cerr << "Failed to open file " << path << std::endl;
        std::exit(EXIT_FAILURE);
    }


    char c;
    while (file >> std::noskipws >> c) {
        switch (c) {
            case '\r':
                resources_cpp_file << "\\r";
                break;

            case '\n':
                resources_cpp_file << "\\n";
                break;

            default:
                resources_cpp_file << c;
                break;
        }
    }

    resources_cpp_file << "\";\n";
}

int main(int argc, char** argv) {
    assert(argc > 3);

    auto resource_hpp_path = argv[1];
    std::stringstream resource_hpp_file_contents;

    auto resource_cpp_path = argv[2];
    std::ofstream resource_cpp_file(resource_cpp_path, std::ios::binary);

    if (!resource_cpp_file.is_open()) {
        std::cerr << "Failed to open file " << resource_hpp_path << std::endl;
        return EXIT_FAILURE;
    }

    resource_cpp_file //
            << "// This file is auto-generated by resource_embedder\n" //
            << "#include \"resources.hpp\"\n";

    // Preamble
    resource_hpp_file_contents //
            << "// This file is auto-generated by resource_embedder\n" //
            << "#ifndef RESOURCE_EMBEDDER_HPP\n" //
            << "#define RESOURCE_EMBEDDER_HPP\n" //
            << "#include <string_view>\n" //
            << "using namespace std::string_view_literals;\n" //
            << "namespace resources {\n";

    for (int i = 3; i < argc; i++) {
        std::cout << "Processing file " << argv[i] << std::endl;
        embed_resource(resource_cpp_file, resource_hpp_file_contents, argv[i]);
    }

    // Epilog
    resource_hpp_file_contents //
            << "}\n" //
            << "#endif\n";

    std::string resource_hpp_file_contents_string = resource_hpp_file_contents.str();
    if (std::ifstream resource_hpp_file_in(resource_hpp_path, std::ios::binary); resource_hpp_file_in.is_open()) {
        std::stringstream old_resource_hpp_file_contents;
        old_resource_hpp_file_contents << resource_hpp_file_in.rdbuf();

        // We are the same don't update this file.
        // This means that we don't need to recompile other files than the resource cpp file.
        if (std::string old_resource_hpp_file_contents_string = old_resource_hpp_file_contents.str();
            old_resource_hpp_file_contents_string == resource_hpp_file_contents_string) {
            std::cout << resource_hpp_path << " has not changed." << std::endl;
            return EXIT_SUCCESS;
        }

        std::cout << resource_hpp_path << " has changed. Generating" << std::endl;
    } else {
        std::cout << resource_hpp_path << " does not exist. Generating..." << std::endl;
    }

    // There are changes.
    // A recompile is necessary.
    std::ofstream resource_hpp_file(resource_hpp_path, std::ios::binary);
    if (!resource_hpp_file.is_open()) {
        std::cerr << "Failed to open file " << resource_hpp_path << std::endl;
    }

    resource_hpp_file << resource_hpp_file_contents_string;
}
